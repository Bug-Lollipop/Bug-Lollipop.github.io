<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Git - Akira's blog
  	
	</title

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="Akira's blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>
	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	#sub-nav .social a.weibo {
		background: url('asset/images/social/weibo.png?1419407210') center no-repeat #4ec4fa;
		border: 1px solid #4ec4fa;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	article .entry-content table th,article .entry-content table td{ padding: 4px;border-collapse: collapse; border:solid 1px #ddd;}
	</style>
	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html">Akira's blog</a></h1>
					<p class="subtitle">记录一些技术文章</p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <li><a href="all.html">Blog</a></li>
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
-->	
								<a class="email" href="mailto:huixiao1008@gmail.com" title="Email">Email</a>
								<a class="weibo" target="_blank" href="https://weibo.com/u/2554601764" title="weibo">Weibo</a>
								
								<a class="github" target="_blank" href="https://github.com/Bug-Lollipop" title="GitHub">GitHub</a>
								<!-- <a class="twitter" target="_blank" href="http://twitter.com/oulvhai" title="Twitter">Twitter</a> -->
								<!-- <a class="rss" href="atom.xml" title="RSS">RSS</a> -->
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">

			<div class="mid-col-container">
		

			
 <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-08-22T17:31:05+08:00" itemprop="datePublished">2018/8/22</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Git.html'>Git</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15349302652828.html" itemprop="url">
		Git 误操作如何将改动撤销？</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>上一篇我们介绍了<a href="https://zhuanlan.zhihu.com/p/39148914">团队工作的github flow 流程</a>，文中主要介绍了主流程，对于开发人员主流程的提交每天都会高频去做，熟练于心。但是在主流程操作中产生失误，遇到的情况相比主流程频率很低很多，对于这些低频失误，相信可能大部分人第一时间会去 Google，寻求解决方案。因此，本文对大家在 Git 使用中遇到的常见的误操作问题做总结归纳，并提供救命建议。</p>

<p>笔者本来打算在一篇文章中介绍全基本的误操作解决方式，但奈何每一种方式都扩充较多，为了让大家更理解，本篇只着重讲解两个方面的误操作。后续的其他方面的解决方式会以连载的方式分享给大家。</p>

<p>本篇介绍的误操作类型主要有以下两个方面：</p>

<ul>
<li>commit - 分支提交错误</li>
<li>reset - 误删代码 </li>
</ul>

<h2 id="toc_0">分支提交错误</h2>

<p>有时我们会遇到这种情况：我们从develop 分支新建一个名为feat/home 分支去做A功能，然后由于一些其他原因A 功能需要延后，然后我们新建一个分支去做B功能或者C功能，在多分支多功能开发时，就容易出现做B任务时，忘记切换分支，一直等做完了提交了push之后才发现 push 错了远端的分支，并且 push 的改动与该分支需要开发的功能并没有交集，因此我们需要将已经提交错的分支内容回滚并提交push 到正确的远端分支：<br/>
 此时有两种情况：</p>

<p>【记得扩充索引和工作目录】</p>

<h3 id="toc_1">场景1：已经commit，但是未push到远端</h3>

<p>使用 <code>git reset</code> 命令，可以在提交层面在私有分支舍弃一些没有提交的更改：</p>

<pre><code> git reset --hard HEAD^ // 回退到上一个版本
</code></pre>

<p>git reset 命令主要有三个选项： --soft、--mixed 、--hard。默认参数为 --mixed</p>

<h4 id="toc_2">git reset --soft 提交：</h4>

<p>--soft 会将 HEAD 指向引用给定提交。索引和工作目录内容保持不变。这个版本的命令有”最小“影响，只改变一个符号引用的状态使其指向一个新提交，不会改变其索引①和工作目录②<br/>
具体体现如下：</p>

<pre><code>git add 1.js &amp;&amp; git commit -m &quot;update part 1&quot;
git add 2.js &amp;&amp; git commit -m &quot;update part 2&quot;
git add 3.js &amp;&amp; git commit -m &quot;update part 3&quot;
git add 4.js &amp;&amp; git commit -m &quot;update part 4&quot;
git log --oneline --graph -4 --decorate
</code></pre>

<p><img src="media/15349302652828/15350139273772.jpg" alt=""/></p>

<pre><code>git reset --soft HEAD~1
</code></pre>

<p>当我们执行--soft 命令时，可以看到控制台无任何输出，此时查看当前提交历史</p>

<pre><code>git log --oneline --graph -4 --decorate
</code></pre>

<p>如下图，可以看到版本库已经回退了一个版本：</p>

<p><img src="media/15349302652828/15350147685109.jpg" alt=""/></p>

<p>执行 <code>git status</code>，可以看到SHA1为<code>54b1941</code> 的commit 上的更改回到了缓存区：<br/>
<img src="media/15349302652828/15350166724510.jpg" alt=""/></p>

<p>因此我们可以 --soft 操作是软重置，只撤销了<code>git commit</code>操作，保留了 <code>git add</code> 操作。</p>

<h4 id="toc_3">git reset --hard 提交</h4>

<p>此时接上面的流程，我们再次执行 <code>--hard</code> 操作，这次尝试回退两个版本：</p>

<pre><code>git reset --hard HEAD~2
</code></pre>

<p>如下图，可以看到版本库回退了两个版本，并且将本地版本库的头指针全部重置到了指定版本，暂存区也会被重置，工作区的代码也回退到了这一版本：</p>

<p><img src="media/15349302652828/15350151330324.jpg" alt=""/></p>

<p>执行<code>git status</code> 可以看到 我们的 “54b1941” commit 上做的修改都&quot;丢失&quot;了，新的文件也被删除了。</p>

<p><img src="media/15349302652828/15350164362840.jpg" alt=""/></p>

<p>因此可以知道，<code>git commit --hard</code> 是具有破坏性，是很危险的操作，它很容易导致数据丢失，如果我们真的进行了该操作想要找回丢失的数据，那么此时可以使用<code>git reflog</code> 命令救命。这个命令的具体使用会在文章后面介绍。 </p>

<h4 id="toc_4">git reset --mixed 提交：</h4>

<p>我们重新造一系列 commit 历史：</p>

<pre><code>git add 1.js &amp;&amp; git commit -m &quot;update 1.js&quot;
git add 2.js &amp;&amp; git commit -m &quot;update 2.js&quot;
git add 3.js &amp;&amp; git commit -m &quot;update 3.js&quot;
git add 4.js &amp;&amp; git commit -m &quot;update 4.js&quot;
git add 5.js &amp;&amp; git commit -m &quot;update 5.js&quot;
git log --oneline --graph -4 --decorate
</code></pre>

<p>可以看到当前的 commit 历史如下：</p>

<p><img src="media/15349302652828/15350212211180.jpg" alt=""/></p>

<p>此时执行--mixed 操作，尝试回退两个版本：</p>

<pre><code># 等价于 git reset HEAD~2
git reset --mixed HEAD~2 
</code></pre>

<p>提交历史此时改变为下图所示：</p>

<p><img src="media/15349302652828/15350216633387.jpg" alt=""/></p>

<p>此时执行 <code>git status</code> ，命令行输出如下：</p>

<p><img src="media/15349302652828/15350217304281.jpg" alt=""/></p>

<p>SourceTree 工具上的直观显示如下：</p>

<p><img src="media/15349302652828/15350220384972.jpg" alt=""/></p>

<p>可以看出，该命令加上 --mixed 参数会保留提交的源码改动，只是将索引信息回退到了某一个版本，如果还需要继续提交，再次执行 <code>git add</code> 和 <code>git commit</code></p>

<p>介绍完<code>git reset</code>，那么我们来说一下如何用该命令解决提交分支错误的问题：</p>

<h5 id="toc_5">第一种方法：</h5>

<p>适用于多个分支一起开发的时候将A分支的改动提交到B的场景：</p>

<pre><code># 将该分支的本不应该提交的commit撤销
git reset HEAD^

# 按需选择想要回到哪个版本
# 回到HEAD
git reset --soft HEAD

# 回到HEAD的前一个版本
git reset --soft HEAD^

# 回到HEAD的前10个版本
git reset --soft HEAD~5 

# 利用id回到指定版本
git reset --soft a06ef2f

# 将撤销的代码暂存起来
git stash

# 切换到正确的分支
git checkout feat/xxx

# 重新应用缓存
git stash pop

# 在正确的分支进行提交操作
git add . &amp;&amp; git commit -m &quot;update xxxx&quot;
</code></pre>

<h5 id="toc_6">第二种方法：</h5>

<p>适用于在不小心在master 分支上提交了代码，而实际想要在feature 分支上提交代码的场景：</p>

<pre><code># 新检出一个新分支，但是仍在master 分支上，并不会切换到新分支
git branch feat/update

# 恢复master本身提交的状态
git reset --hard origin/master

# 提交错的代码已经在新检出的分支上面了，可以继续进行开发或者push
git checkout feat/update
</code></pre>

<p>第三种方法：</p>

<ol>
<li>适用于想要对特定的某一个或几个commit 进行“嫁接”，使其复制一份到正确的feature 分支的场景；</li>
<li>在功能性迭代开发中发现一个bug，并提交了一个commit 进行修复，但是发现该bug也存在线上的发布版本上，必须要尽快对线上进行修复，此时可以使用<code>git cherry-pick</code> 来将bug 修复的commit 嫁接到 fix 分支上进行代码修复，并及时发布，解决线上bug的场景。</li>
</ol>

<pre><code># 先切换到正确的分支
git checkout feat/update

# 取出提交错误的或bug fix的 commit 引入到feat/update 分支中
git cherry-pick a06ef2f

# 回到错误的分支
git checkout feat/feedback

# 将 a06ef2f 的改动从当前分支销毁
git reset --head a06ef2f 
</code></pre>

<p>上面演示的是“嫁接” 一个commit，如果想要嫁接多个commit可以这样做：</p>

<pre><code># 将三个commit 合并过来
git cherry-pick b9dabf9 e2c739d dad9e51 
</code></pre>

<p>如果想加个一个应用范围内的commit，可以这样做：</p>

<pre><code>git cherry-pick 422db47..e2c739d
</code></pre>

<p>需要主要的是无论是对单个 commit 进行 <code>git cherry-pick</code> ，还是批量处理，注意一定要根据时间线，依照 commit 的先后顺序来处理。</p>

<p>如果你只想把改动转移到目标分支，但是并不想提交，可以这样做：</p>

<pre><code># 嫁接过来的改动不会提交，只会放在暂存区
git cherry-pick b9dabf9 --no-commit
</code></pre>

<h5 id="toc_7">第四种方法：</h5>

<p>适用于当多个文件被缓存时，发现其中一个文件是其他分支的功能性改动，想直接取消该文件的缓存：</p>

<pre><code># 编辑了 1.js 2.js 3.js
# 缓存所有改动的文件
git add .

# 发现 3.js 不应该出现在此时提交的功能上，要取消它的缓存
git reset 3.js

# 此时3.js 被取消了缓存，我们继续提交1.js 2.js
git commit -m &quot;Update 1.js 2.js&quot;

# 将3.js 暂存起来
git stash

# 切换到提交 3.js 改动的分支
git checkout feat/update

# 重新应用缓存起来的 stash（3.js）
#pop 参数会将缓存栈的第一个stash删除，并将对应修改应用到当前分支目录下
git stash pop

# 继续提交
git add &amp;&amp; git commit -m &quot;update 3.js&quot;

</code></pre>

<h3 id="toc_8">场景2：Commit之后已经 push 到了远端</h3>

<p>此时我们需要借助 <code>git revert</code> 命令来撤销我们的操作</p>

<p>场景：假设我们在feat/feedback 分支上发现最后一次commit的功能是feat/update 分支的改动，此时想要取消这次commit（update 2.js）</p>

<p>下图是feat/feedback 的提交历史：</p>

<p><img src="media/15349302652828/15350814730126.jpg" alt=""/></p>

<p>解决方式：</p>

<pre><code># 撤销最近的一次提交
git revert HEAD --no-edit
</code></pre>

<p>接着我们使用sourceTree ④查看撤销之后的提交历史：</p>

<p><img src="media/15349302652828/15350902771287.jpg" alt=""/></p>

<p>我们看到想要撤销的commit（Update 2.js）记录还在，并且多了一个新的commit（Revert &quot;Update 2.js&quot;），因此可以看出，git revert 是对给定的commit提交进行逆过程，该命令会引入一个新的提交来的小给定提交的影响。<br/>
和 <code>git cherry-pick</code> 一样，revert命令不修改版本库的现存历史记录，相反它只会在记录添加新的提交</p>

<p>接下来我们已经解决了错误分支的提交，但是还要把这次提交放到正确的分支上，依然可以使用git cherry pick 去操作：</p>

<pre><code># 将revert commit push到远端
git push origin feat/feedback

# 切换到正确的分支
git checkout feat/update

将目标commit 嫁接到当前分支
git cherry pick db6bb3f
</code></pre>

<p>git revert 后面可以加不同的参数达到不同的撤销效果，常用的如下：</p>

<p><code>--edit</code> ：该参数为<code>git revert</code> 的默认参数，它会自动创建提交日志提醒，此时会弹出编辑器会话，可以在里面修改提交消息，然后再提交。</p>

<p><code><br/>
git revert 6ac5152 <br/>
</code></p>

<p><img src="media/15349302652828/15350916473467.jpg" alt=""/></p>

<p><code>--no-edit</code> ：表示不編輯 Commit 訊息，revert的commit 会直接自动变回 Revert + 想要撤销的commit 的message 的格式。上面例子中使用的就是这种方式。</p>

<p><code>--no-commit</code>：该命令会使撤销的commit 里面的改动放到暂存区，不进行提交，用户可以自行再次提交。这种参数并且适用于将多个commit 结果还原到索引中，集体放置在缓冲区，进行用户自定义的操作。</p>

<pre><code>git revert 13b7faf --no-commit
</code></pre>

<p><img src="media/15349302652828/15350923959888.jpg" alt=""/></p>

<p><img src="media/15349302652828/15350919592687.jpg" alt=""/></p>

<h3 id="toc_9">场景3：改动不仅已经 push 到远端，并且已经合到主仓库</h3>

<p>当我们把本不属于该分支的代码或者不需要提交的改动提交到主仓库，并合并到了develop 仓库之后，解决方式如下：</p>

<h4 id="toc_10">以pull request 的方式进行的合并</h4>

<p>在团队的github flow 流程中，若我们把问题分支的pull request 请求通过并合并到develop 之后，我们可以看到在 open pull request 页面有如下提示：</p>

<p><img src="media/15349302652828/15350949829300.jpg" alt=""/></p>

<p>这时我们可以直接点击 【Revert】按钮进行撤回。该撤回操作会提示你需要创建一个 revert pull request，格式默认为： <code>revert-${问题pr号}-${问题分支}</code></p>

<p><img src="media/15349302652828/15350952135446.jpg" alt=""/></p>

<p><img src="media/15349302652828/15350954062379.jpg" alt=""/></p>

<p>最后我们将revert 产生的pull request 合并到develop 分支。</p>

<p>因此对于团队协作中，推荐的工作流程是如上图所示在一个新分支中恢复错误的提交。在这里有人会问，为什么不直接在 develop 分支进行 git revert 操作，岂不是更方便？</p>

<p>这么做的原因是：在拥有大量开发人员的团队中， develop、master 分支为保护分支，为了安全不允许或建议去直接修改。</p>

<p>通过这次操作我们可以了解到：revert 分支的操作实际上是合并进develop 分支的逆操作，它会新产生一个新的分支，将 feat/feedback 的改动还原。</p>

<p>在团队协作流程中，通常我们会使用 Github 的【Merge pull request】 绿色按钮进行合并pull request 的操作，因为这样会更简单直观，建议始终使用该绿色按钮进行操作。</p>

<h4 id="toc_11">命令行合并</h4>

<p>上面展示了通过界面按钮去操作如何撤销已经合并develop 分支的改动，那么在个人项目中用命令行操作是怎么样的呢？</p>

<pre><code># 添加三个文件
echo 1 &gt; 1.html
echo 2 &gt; 2.html
echo 3 &gt; 3.html

# 以为提交的是1.html 2.html，将改动推到了远端分支
git add . &amp;&amp; git commit -m &quot;Add 1.html 2.html&quot;
git push origin feat/update

# 将feat/update的改动创建一个“合并提交”合入develop 分支，生成的 Merge commit 的SHA1 为 f439c6f
git checkout develop
git merge feat/update --no-ff

# 如果存在冲突，先解决冲突，然后继续请求合并
git add . &amp;&amp; git merge --continue

# 将develop 合并的最后结果提交到远端
git push origin develop

# 合并之后发现不应该将3.html 不应该放入功能迭代中。需要撤销本次合并
# 做任何操作前，先保证本地的develop 代码是最新状态
git pull --rebase origin develop

# 从develop分支新建一个 revert 分支
git checkout -b revert-feat/update

# 用 -m 参数指定父编号（从1开始），因为它是“合并提交⑤”
git revert -m 1 f439c6f

# push revert 的改动
git push origin revert-feat/update

# 切换回 develop 分支，将 revert-feat/update 分支进行合并
git checkout develop
git merge revert-feat/update --no-ff
git push origin develop
</code></pre>

<p>图为新建revert 分支：<br/>
<img src="media/15349302652828/15351016084946.jpg" alt=""/></p>

<p>图为<code>git revert</code> 弹出编辑器编辑 revert commit message 过程：<br/>
<img src="media/15349302652828/15351016878245.jpg" alt=""/></p>

<p>图为执行完<code>git revert</code> 之后的 commit 历史记录：<br/>
<img src="media/15349302652828/15351017135058.jpg" alt=""/></p>

<p>接下来我们想将3.html 的改动撤销的操作就变成了上面场景 2 的操作流程了。</p>

<h3 id="toc_12">场景4 revert 错误，需要再次补救</h3>

<p>当我们的代码合到主仓库，并且成功发布到生产环境，此时发现线上有集中报错，必须马上将线上代码回滚到最新版本。这是我们需要进行revert 操作。revert 的代码发布到生产之后，发现错误仍旧存在，最后排查到是某个外部服务依赖出现问题，本次revert 的改动无关，并且外部服务已经恢复。此时需要将 revert 的改动再次发布上生产环境。</p>

<p>我们可以再用一次<code>git revert</code>，revert 掉我们之前的 revert commit：</p>

<pre><code>git revert HEAD --no-edit
</code></pre>

<p>这样 revert 撤销的改动又回来了，此时会发现提交历史上又会出现一个新的revert commit。</p>

<h2 id="toc_13">误删代码</h2>

<p>介绍上面提交错误 commit的时候，我们提到了<code>git reset --hard</code>。<br/>
如果我们真的使用了<code>git reset --hard</code> 之后，发现某些修改还有必要的，这时候就需要借助时光机 <code>git reflog</code> 了</p>

<p><code>git reflog</code> 是非常好用的“后悔药”，它几乎可以恢复我们commit 过的改动，即使这条 commit 记录已经被我们 reset 掉了。</p>

<p>具体演示如下：<br/>
<img src="media/15349302652828/15351158334047.jpg" alt=""/></p>

<p>如上图，在当前提交历史中，我们想回到 SHA1 为 <code>c48a245</code> 这个commit：</p>

<pre><code># 回到 c48a245 commit
git reset --hard c48a245
</code></pre>

<p>此时提交历史变为现在这样：<br/>
<img src="media/15349302652828/15351159943422.jpg" alt=""/></p>

<p>此时可以看到SHA1 为<code>c48a245</code> 的 commit 时间线之后的改动都已经被撤销了。<br/>
这时候我们突然想到：commit 信息为 “Add 1.html 2.html” 的提交里面的改动很重要，需要被找回，但是我们使用 <code>git log</code> 已经找不到这条被我们reset 掉的历史记录了。这时候进行如下操作：</p>

<pre><code>git reflog
</code></pre>

<p><img src="media/15349302652828/15351170241290.jpg" alt=""/></p>

<p>我们看到了曾经提交过的这个想要找回的commit（commit: Add 1.html 2.html），它的 SHA1 为 <code>cf2e245</code></p>

<p>接下来怎么做取决于你具体想要达到什么目的：</p>

<ul>
<li>想要回到<code>cf2e245</code> 这个特定的commit：</li>
</ul>

<pre><code>git reset --hard cf2e245
</code></pre>

<ul>
<li>想要暂存 <code>cf2e245</code> 中的改动，并且不想马上提交：</li>
</ul>

<pre><code>git reset --soft cf2e245
</code></pre>

<ul>
<li>想要把<code>cf2e245</code> 嫁接到某个分支目录下：</li>
</ul>

<pre><code>git checkout feat/xxx
git cherry-pick cf2e245
</code></pre>

<ul>
<li>想要找回 <code>cf2e245</code> 某个文件的改动，暂存起来：</li>
</ul>

<pre><code>git checkout cf2e245 1.html
</code></pre>

<p><img src="media/15349302652828/15351178789682.jpg" alt=""/></p>

<p>对于 <code>git reflog</code> 需要注意的是： 它不是万能的。Git 会定期清理那些你已经不再用到的”对象“，如果你想找到几个月以前的提交，可能会指望不上它。</p>

<h2 id="toc_14">写在后面</h2>

<p>上面由于篇幅原因只总结了两种撤销操作，后续还会总结归纳一些网络上大家咨询最多的错误的解决方式。</p>

<p>文中的一些想法都是笔者工作学习过程中的思考和一点小小的总结。笔者认为技术某些名词翻译过来可能会有些许词不达意，因此文中某些操作词并没有直接翻译成中文，而是直接以英文形式存在，如果对其中的命令有疑问的同学，可以利用搜索引擎去了解更多。如有错误，欢迎指正！</p>

<hr/>

<p>一些名词注解：</p>

<p>① 索引：</p>

<blockquote>
<p>Git索引是一个在你的工作目录和项目仓库间的暂存区(staging area)。有了它， 你可以把许多内容的修改一起提交（commit）。 如果你创建了一个提交（commit），那么提交的是当前索引（index）里的内容，而不是工作目录中的内容。</p>
</blockquote>

<p>② 工作目录：</p>

<blockquote>
<p>Git工作目录存储着你现在签出(checkout)来用来编辑的文件. 当你在项目的不同分支间切换时， 工作目录里的文件经常会被替换和删除。 所有历史信息都保存在 &#39;Git目录&#39;中；　工作目录只用来临时保存签出（checkout） 文件的地方， 你可以编辑工作目录的文件直到下次提交（commit）为止。</p>
</blockquote>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-08-15T16:26:28+08:00" itemprop="datePublished">2018/8/15</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Git.html'>Git</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15343215883524.html" itemprop="url">
		Git 拼接特定commit 到其他分支</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><a href="https://blog.csdn.net/ybdesire/article/details/42145597">https://blog.csdn.net/ybdesire/article/details/42145597</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-07-31T18:53:02+08:00" itemprop="datePublished">2018/7/31</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Git.html'>Git</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15330343829802.html" itemprop="url">
		Git 笔记一 —— 对象类型</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>对象库是Git 版本库的心脏，包含所有舒适数据文件和所有日志消息、作业信息、日期、以及其他用来重建项目任何版本和分支的信息。</p>

<p>Git 放在对象库的对象只有四种类型： 块（blob）、目录树（tree）、提交（commit）和标签（tag）。</p>

<h4 id="toc_0">块（blob）</h4>

<p>文件的每个版本表示为一个块（blob）。blob 是 “二进制大对象”（binary large object） </p>

<h4 id="toc_1">目录树（tree）</h4>

<p>一个目录树（tree）对象代表一层目录信息。它记录blob 标识符、路径名和在一个目录里所有文件的一些元数据</p>

<h4 id="toc_2">提交（commit）</h4>

<p>一个提交对象保存版本库中每一次变化的元数据，包括作者、提交者、提交日期和日志消息。每一个提交对象指向一个目录树对象</p>

<h4 id="toc_3">标签（tag）</h4>

<p>一个标签对象分配一个任意的且人类可读的名字给一个特定的对象，通常是一个提交对象。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-05-25T17:24:35+08:00" itemprop="datePublished">2018/5/25</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Git.html'>Git</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15272402756177.html" itemprop="url">
		团队协作中的 Github flow 工作流程</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>作为一名开发人员 Git 常用命令每天都在使用，大家肯定信手捏来，但是在团队协作中 Git的使用姿势和个人开发还是有很多不一样的地方，对于技术团队，期望大家使用规范的 Git 操作流程，规范的 Commit Message，规范的代码风格。这样才能提高团队开发相率和项目的可维护性。今天主要为大家介绍一基于 Github flow 的一套 Git 操作流程。</p>

<h3 id="toc_0">fork</h3>

<p>首先，多人协作的情况，我们通常会 fork团队项目主仓库到自己的托管空间下，然后 Clone 到本地进行开发,<br/>
假设团队项目的托管地址为：<br/>
<a href="https://github.com/elemeFe/github-flow">https://github.com/elemeFe/github-flow</a></p>

<p>此时主仓库项目下的固定分支两个，分别是 master，develop。<br/>
<img src="media/15272402756177/15306918990981.jpg" alt=""/></p>

<p>Clone 到本地：</p>

<pre><code>git clone git@github.com:fe/github-flow.git
</code></pre>

<p>假设上面主仓库 fork 之后的项目地址为：</p>

<p><a href="">https://github.com/xxx/github-flow</a></p>

<p>Fork 出来的仓库完全属于你自己，你可以任意修改该仓库的代码及配置，但是除非你向项目主仓库提交 pull request，并且被接受通过，你才可以将你fork 仓库修改的代码合并到主仓库，否则不会对主仓库产生任何影响。</p>

<p>此时可以在控制台输入 <code>git remote -v</code> 命令查看当前远端仓库的地址，输出如下：</p>

<pre><code>origin  git@github.com:xxx/github-flow.git (fetch)
origin  git@github.com:xxx/github-flow.git (push)
</code></pre>

<p>可以看出该地址的远端（origin）为刚刚 fork 到自己的托管空间下项目地址。</p>

<p>接下来我们可以设置一个名字为 upstream 的上游地址，也就是我们项目主仓库的地址<br/>
在命令行执行：</p>

<pre><code> git remote add upstream git@github.com:fe/github-flow.git` 
</code></pre>

<p>添加一个别名为upstream(上游)的地址，指向之前 fork 的原项目仓库地址。<br/>
再次执行 <code>git remote -v</code> 控制台输出如下：</p>

<pre><code>origin  git@github.com:xxx/github-flow.git (fetch)
origin  git@github.com:xxx/github-flow.git (push)
upstream    git@github.com:fe/github-flow.git (fetch)
upstream    git@github.com:fe/github-flow.git (push)
</code></pre>



			 
			<a href="15272402756177.html#more" class="more-link">Read on &rarr;</a>
    		
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2018-02-13T11:43:49+08:00" itemprop="datePublished">2018/2/13</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Git.html'>Git</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15184934292641.html" itemprop="url">
		SSH 多账户使用</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>参考github 的 <a href="https://help.github.com/articles/connecting-to-github-with-ssh/">Connecting to GitHub with SSH</a></p>

<h3 id="toc_0">检查 SSH Keys 是否存在</h3>

<pre><code>ls -al ~/.ssh
</code></pre>



			 
			<a href="15184934292641.html#more" class="more-link">Read on &rarr;</a>
    		
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-11-02T16:02:37+08:00" itemprop="datePublished">2017/11/2</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Git.html'>Git</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15184258575559.html" itemprop="url">
		git bisect</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>git bisect 是 Git 提供的一种 二分法 的调试工具，它可以按照我们选定的提交，进行二分分割，快速定位出出错的提交。来帮我们缩小最小改动的代码，从而快速定位问题。</p>

<p><code>git bisect</code> 基于几个基本命令：</p>

<p>git bisect start：准备进行 bisect debug。<br/>
git bisect good：标记一个提交为 “good”。<br/>
git bisect bad：标记一个提交为 “bad”。<br/>
git bisect reset：退出 bisect debug 的状态。</p>



			 
			<a href="15184258575559.html#more" class="more-link">Read on &rarr;</a>
    		
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
	
	</div>
<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>